# This file is part of GridCal.
#
# GridCal is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GridCal is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GridCal.  If not, see <http://www.gnu.org/licenses/>.

import numpy as np
import pandas as pd
import scipy.sparse as sp
from typing import List, Dict

from GridCal.Engine.basic_structures import Logger
import GridCal.Engine.Core.topology as tp
from GridCal.Engine.Core.multi_circuit import MultiCircuit
from GridCal.Engine.basic_structures import BranchImpedanceMode
from GridCal.Engine.basic_structures import BusMode
from GridCal.Engine.Simulations.PowerFlow.jacobian_based_power_flow import Jacobian
from GridCal.Engine.Core.common_functions import compile_types, find_different_states
from GridCal.Engine.Simulations.sparse_solve import get_sparse_type
from GridCal.Engine.Simulations.OPF.opf_ts_results import OptimalPowerFlowTimeSeriesResults


sparse_type = get_sparse_type()


class TimeCircuit:

    def __init__(self, nbus, nline, ntr, nvsc, nhvdc, nload, ngen, nbatt, nshunt, nstagen, ntime, sbase, time_array,
                 apply_temperature=False, branch_tolerance_mode: BranchImpedanceMode = BranchImpedanceMode.Specified):
        """

        :param nbus: number of buses
        :param nline: number of lines
        :param ntr: number of transformers
        :param nvsc:
        :param nhvdc:
        :param nload:
        :param ngen:
        :param nbatt:
        :param nshunt:
        """

        self.nbus = nbus
        self.nline = nline
        self.ntr = ntr
        self.nvsc = nvsc
        self.nhvdc = nhvdc
        self.nload = nload
        self.ngen = ngen
        self.nbatt = nbatt
        self.nshunt = nshunt
        self.nstagen = nstagen
        self.ntime = ntime

        self.Sbase = sbase

        self.apply_temperature = apply_temperature
        self.branch_tolerance_mode = branch_tolerance_mode

        self.time_array = time_array

        # bus ----------------------------------------------------------------------------------------------------------
        self.bus_names = np.empty(nbus, dtype=object)
        self.bus_types = np.empty(nbus, dtype=int)
        self.bus_installed_power = np.zeros(nbus, dtype=float)

        self.bus_active = np.ones((ntime, nbus), dtype=int)
        self.Vbus = np.ones((ntime, nbus), dtype=complex)
        self.Vmin = np.ones(nbus)
        self.Vmax = np.ones(nbus)

        # branch common ------------------------------------------------------------------------------------------------
        self.nbr = nline + ntr + nhvdc + nvsc  # compute the number of branches

        self.branch_names = np.empty(self.nbr, dtype=object)
        self.branch_active = np.zeros((ntime, self.nbr), dtype=int)
        self.F = np.zeros(self.nbr, dtype=int)  # indices of the "from" buses
        self.T = np.zeros(self.nbr, dtype=int)  # indices of the "to" buses
        self.branch_rates = np.zeros((ntime, self.nbr), dtype=float)
        self.C_branch_bus_f = sp.lil_matrix((self.nbr, nbus), dtype=int)  # connectivity branch with their "from" bus
        self.C_branch_bus_t = sp.lil_matrix((self.nbr, nbus), dtype=int)  # connectivity branch with their "to" bus

        # lines --------------------------------------------------------------------------------------------------------
        self.line_names = np.zeros(nline, dtype=object)
        self.line_R = np.zeros(nline, dtype=float)
        self.line_X = np.zeros(nline, dtype=float)
        self.line_B = np.zeros(nline, dtype=float)
        self.line_temp_base = np.zeros(nline, dtype=float)
        self.line_temp_oper = np.zeros(nline, dtype=float)
        self.line_alpha = np.zeros(nline, dtype=float)
        self.line_impedance_tolerance = np.zeros(nline, dtype=float)

        self.C_line_bus = sp.lil_matrix((nline, nbus), dtype=int)  # this ons is just for splitting islands

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        self.tr_names = np.zeros(ntr, dtype=object)
        self.tr_R = np.zeros(ntr, dtype=float)
        self.tr_X = np.zeros(ntr, dtype=float)
        self.tr_G = np.zeros(ntr, dtype=float)
        self.tr_B = np.zeros(ntr)

        self.tr_tap_f = np.ones(ntr)  # tap generated by the difference in nominal voltage at the form side
        self.tr_tap_t = np.ones(ntr)  # tap generated by the difference in nominal voltage at the to side
        self.tr_tap_mod = np.ones(ntr)  # normal tap module
        self.tr_tap_ang = np.zeros(ntr)  # normal tap angle
        self.tr_is_bus_to_regulated = np.zeros(ntr, dtype=bool)
        self.tr_bus_to_regulated_idx = np.zeros(ntr, dtype=int)
        self.tr_tap_position = np.zeros(ntr, dtype=int)
        self.tr_min_tap = np.zeros(ntr, dtype=int)
        self.tr_max_tap = np.zeros(ntr, dtype=int)
        self.tr_tap_inc_reg_up = np.zeros(ntr)
        self.tr_tap_inc_reg_down = np.zeros(ntr)
        self.tr_vset = np.ones(ntr)

        self.C_tr_bus = sp.lil_matrix((ntr, nbus), dtype=int)  # this ons is just for splitting islands

        # hvdc line ----------------------------------------------------------------------------------------------------
        self.hvdc_names = np.zeros(nhvdc, dtype=object)

        self.hvdc_active = np.zeros((ntime, nhvdc), dtype=bool)
        self.hvdc_rate = np.zeros((ntime, nhvdc), dtype=float)
        self.hvdc_Pset = np.zeros((ntime, nhvdc))
        self.hvdc_Vset_f = np.zeros((ntime, nhvdc))
        self.hvdc_Vset_t = np.zeros((ntime, nhvdc))

        self.hvdc_loss_factor = np.zeros(nhvdc)
        self.hvdc_Qmin_f = np.zeros(nhvdc)
        self.hvdc_Qmax_f = np.zeros(nhvdc)
        self.hvdc_Qmin_t = np.zeros(nhvdc)
        self.hvdc_Qmax_t = np.zeros(nhvdc)

        self.C_hvdc_bus_f = sp.lil_matrix((nhvdc, nbus), dtype=int)  # this ons is just for splitting islands
        self.C_hvdc_bus_t = sp.lil_matrix((nhvdc, nbus), dtype=int)  # this ons is just for splitting islands

        # vsc converter ------------------------------------------------------------------------------------------------
        self.vsc_names = np.zeros(nvsc, dtype=object)
        self.vsc_R1 = np.zeros(nvsc)
        self.vsc_X1 = np.zeros(nvsc)
        self.vsc_Gsw = np.zeros(nvsc)
        self.vsc_Beq = np.zeros(nvsc)
        self.vsc_m = np.zeros(nvsc)
        self.vsc_theta = np.zeros(nvsc)

        self.C_vsc_bus = sp.lil_matrix((nvsc, nbus), dtype=int)  # this ons is just for splitting islands

        # load ---------------------------------------------------------------------------------------------------------
        self.load_names = np.empty(nload, dtype=object)
        self.load_active = np.zeros((ntime, nload), dtype=bool)
        self.load_s = np.zeros((ntime, nload), dtype=complex)

        self.C_bus_load = sp.lil_matrix((nbus, nload), dtype=int)

        # static generators --------------------------------------------------------------------------------------------
        self.static_generator_names = np.empty((nstagen, nload), dtype=object)
        self.static_generator_active = np.zeros((nstagen, nload), dtype=bool)
        self.static_generator_s = np.zeros((nstagen, nload), dtype=complex)

        self.C_bus_static_generator = sp.lil_matrix((nbus, nstagen), dtype=int)

        # battery ------------------------------------------------------------------------------------------------------
        self.battery_names = np.empty(nbatt, dtype=object)
        self.battery_active = np.zeros((ntime, nbatt), dtype=bool)
        self.battery_controllable = np.zeros(nbatt, dtype=bool)
        self.battery_installed_p = np.zeros(nbatt)
        self.battery_p = np.zeros((ntime, nbatt))
        self.battery_pf = np.zeros((ntime, nbatt))
        self.battery_v = np.zeros((ntime, nbatt))
        self.battery_qmin = np.zeros(nbatt)
        self.battery_qmax = np.zeros(nbatt)

        self.C_bus_batt = sp.lil_matrix((nbus, nbatt), dtype=int)

        # generator ----------------------------------------------------------------------------------------------------
        self.generator_names = np.empty(ngen, dtype=object)
        self.generator_active = np.zeros((ntime, ngen), dtype=bool)
        self.generator_controllable = np.zeros(ngen, dtype=bool)
        self.generator_installed_p = np.zeros(ngen)
        self.generator_p = np.zeros((ntime, ngen))
        self.generator_pf = np.zeros((ntime, ngen))
        self.generator_v = np.zeros((ntime, ngen))
        self.generator_qmin = np.zeros(ngen)
        self.generator_qmax = np.zeros(ngen)

        self.C_bus_gen = sp.lil_matrix((nbus, ngen), dtype=int)

        # shunt --------------------------------------------------------------------------------------------------------
        self.shunt_names = np.empty(nshunt, dtype=object)
        self.shunt_active = np.zeros((ntime, nshunt), dtype=bool)
        self.shunt_admittance = np.zeros((ntime, nshunt), dtype=complex)

        self.C_bus_shunt = sp.lil_matrix((nbus, nshunt), dtype=int)

    def consolidate(self):
        """
        Consolidates the information of this object
        :return:
        """
        self.C_branch_bus_f = self.C_branch_bus_f.tocsc()
        self.C_branch_bus_t = self.C_branch_bus_t.tocsc()

        self.C_line_bus = self.C_line_bus.tocsc()
        self.C_tr_bus = self.C_tr_bus.tocsc()
        self.C_hvdc_bus_f = self.C_hvdc_bus_f.tocsc()
        self.C_hvdc_bus_t = self.C_hvdc_bus_t.tocsc()
        self.C_vsc_bus = self.C_vsc_bus.tocsc()

        self.C_bus_load = self.C_bus_load.tocsr()
        self.C_bus_batt = self.C_bus_batt.tocsr()
        self.C_bus_gen = self.C_bus_gen.tocsr()
        self.C_bus_shunt = self.C_bus_shunt.tocsr()
        self.C_bus_static_generator = self.C_bus_static_generator.tocsr()

        self.bus_installed_power = self.C_bus_gen * self.generator_installed_p
        self.bus_installed_power += self.C_bus_batt * self.battery_installed_p

    def get_power_injections(self):
        """
        Compute the power
        :return: Array of power injections
        """

        # load
        Sbus = - self.C_bus_load * (self.load_s * self.load_active)  # MW

        # static generators
        Sbus += self.C_bus_static_generator * (self.static_generator_s * self.static_generator_active)  # MW

        # generators
        Sbus += self.C_bus_gen * (self.generator_p * self.generator_active)

        # battery
        Sbus += self.C_bus_batt * (self.battery_p * self.battery_active)

        # HVDC forced power
        if self.nhvdc:
            Sbus += self.hvdc_active * self.hvdc_Pset * self.C_hvdc_bus_f
            Sbus -= self.hvdc_active * self.hvdc_Pset * self.C_hvdc_bus_t

        Sbus /= self.Sbase

        return Sbus

    def to_island(self) -> "TimeIsland":
        """
        copy the circuit as an island device
        :return: TimeIsland instance
        """
        island = TimeIsland(nbus=self.nbus,
                            nline=self.nline,
                            ntr=self.ntr,
                            nvsc=self.nvsc,
                            nhvdc=self.nhvdc,
                            nload=self.nload,
                            ngen=self.ngen,
                            nbatt=self.nbatt,
                            nshunt=self.nshunt,
                            nstagen=self.nstagen,
                            ntime=self.ntime,
                            sbase=self.Sbase,
                            time_array=self.time_array,
                            apply_temperature=self.apply_temperature,
                            branch_tolerance_mode=self.branch_tolerance_mode)

        island.original_time_idx = np.arange(self.ntime)
        island.original_bus_idx = np.arange(self.nbus)
        island.original_branch_idx = np.arange(self.nbr)
        island.original_tr_idx = np.arange(self.ntr)
        island.original_gen_idx = np.arange(self.ngen)
        island.original_bat_idx = np.arange(self.nbatt)

        # bus ----------------------------------------------------------------------------------------------------------
        island.bus_names = self.bus_names
        island.bus_active = self.bus_active
        island.bus_installed_power = self.bus_installed_power
        island.Vbus = self.Vbus
        island.bus_types = self.bus_types

        # branches common ----------------------------------------------------------------------------------------------
        island.branch_names = self.branch_names
        island.branch_active = self.branch_active
        island.F = self.F
        island.T = self.T
        island.branch_rates = self.branch_rates
        island.C_branch_bus_f = self.C_branch_bus_f
        island.C_branch_bus_t = self.C_branch_bus_t

        # lines --------------------------------------------------------------------------------------------------------
        island.line_names = self.line_names
        island.line_R = self.line_R
        island.line_X = self.line_X
        island.line_B = self.line_B
        island.line_temp_base = self.line_temp_base
        island.line_temp_oper = self.line_temp_oper
        island.line_alpha = self.line_alpha
        island.line_impedance_tolerance = self.line_impedance_tolerance

        island.C_line_bus = self.C_line_bus

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        island.tr_names = self.tr_names
        island.tr_R = self.tr_R
        island.tr_X = self.tr_X
        island.tr_G = self.tr_G
        island.tr_B = self.tr_B

        island.tr_tap_f = self.tr_tap_f
        island.tr_tap_t = self.tr_tap_t
        island.tr_tap_mod = self.tr_tap_mod
        island.tr_tap_ang = self.tr_tap_ang
        island.tr_is_bus_to_regulated = self.tr_is_bus_to_regulated
        island.tr_tap_position = self.tr_tap_position
        island.tr_min_tap = self.tr_min_tap
        island.tr_max_tap = self.tr_max_tap
        island.tr_tap_inc_reg_up = self.tr_tap_inc_reg_up
        island.tr_tap_inc_reg_down = self.tr_tap_inc_reg_down
        island.tr_vset = self.tr_vset

        island.C_tr_bus = self.C_tr_bus

        # hvdc line ----------------------------------------------------------------------------------------------------
        island.hvdc_names = self.hvdc_names
        island.hvdc_active = self.hvdc_active
        island.hvdc_rate = self.hvdc_rate

        island.hvdc_Pset = self.hvdc_Pset
        island.hvdc_loss_factor = self.hvdc_loss_factor

        island.hvdc_Vset_f = self.hvdc_Vset_f
        island.hvdc_Vset_t = self.hvdc_Vset_t

        island.hvdc_Qmin_f = self.hvdc_Qmin_f
        island.hvdc_Qmax_f = self.hvdc_Qmax_f
        island.hvdc_Qmin_t = self.hvdc_Qmin_t
        island.hvdc_Qmax_t = self.hvdc_Qmax_t

        island.C_hvdc_bus_f = self.C_hvdc_bus_f
        island.C_hvdc_bus_f = self.C_hvdc_bus_t

        # vsc converter ------------------------------------------------------------------------------------------------
        island.vsc_names = self.vsc_names
        island.vsc_R1 = self.vsc_R1
        island.vsc_X1 = self.vsc_X1
        island.vsc_Gsw = self.vsc_Gsw
        island.vsc_Beq = self.vsc_Beq
        island.vsc_m = self.vsc_m
        island.vsc_theta = self.vsc_theta

        island.C_vsc_bus = self.C_vsc_bus

        # load ---------------------------------------------------------------------------------------------------------
        island.load_names = self.load_names
        island.load_active = self.load_active
        island.load_s = self.load_s

        island.C_bus_load = self.C_bus_load

        # static generators --------------------------------------------------------------------------------------------
        island.static_generator_names = self.static_generator_names
        island.static_generator_active = self.static_generator_active
        island.static_generator_s = self.static_generator_s

        island.C_bus_static_generator = self.C_bus_static_generator

        # battery ------------------------------------------------------------------------------------------------------
        island.battery_names = self.battery_names
        island.battery_active = self.battery_active
        island.battery_controllable = self.battery_controllable
        island.battery_installed_p = self.battery_installed_p

        island.battery_p = self.battery_p
        island.battery_pf = self.battery_pf
        island.battery_v = self.battery_v
        island.battery_qmin = self.battery_qmin
        island.battery_qmax = self.battery_qmax

        island.C_bus_batt = self.C_bus_batt

        # generator ----------------------------------------------------------------------------------------------------
        island.generator_names = self.generator_names
        island.generator_active = self.generator_active
        island.generator_controllable = self.generator_controllable
        island.generator_installed_p = self.generator_installed_p

        island.generator_p = self.generator_p
        island.generator_pf = self.generator_pf
        island.generator_v = self.generator_v
        island.generator_qmin = self.generator_qmin
        island.generator_qmax = self.generator_qmax

        island.C_bus_gen = self.C_bus_gen

        # shunt --------------------------------------------------------------------------------------------------------
        island.shunt_names = self.shunt_names
        island.shunt_active = self.shunt_active
        island.shunt_admittance = self.shunt_admittance

        island.C_bus_shunt = self.C_bus_shunt

        return island

    def get_island(self, bus_idx, time_idx) -> "TimeIsland":
        """
        Get the island corresponding to the given buses
        :param bus_idx: array of bus indices
        :param time_idx: array of time indices
        :return: TimeIsland
        """

        # find the indices of the devices of the island
        line_idx = tp.get_elements_of_the_island(self.C_line_bus, bus_idx)
        tr_idx = tp.get_elements_of_the_island(self.C_tr_bus, bus_idx)
        vsc_idx = tp.get_elements_of_the_island(self.C_vsc_bus, bus_idx)
        hvdc_idx = tp.get_elements_of_the_island(self.C_hvdc_bus_f + self.C_hvdc_bus_t, bus_idx)
        br_idx = tp.get_elements_of_the_island(self.C_branch_bus_f + self.C_branch_bus_t, bus_idx)

        load_idx = tp.get_elements_of_the_island(self.C_bus_load.T, bus_idx)
        stagen_idx = tp.get_elements_of_the_island(self.C_bus_static_generator.T, bus_idx)
        gen_idx = tp.get_elements_of_the_island(self.C_bus_gen.T, bus_idx)
        batt_idx = tp.get_elements_of_the_island(self.C_bus_batt.T, bus_idx)
        shunt_idx = tp.get_elements_of_the_island(self.C_bus_shunt.T, bus_idx)

        nc = TimeIsland(nbus=len(bus_idx),
                        nline=len(line_idx),
                        ntr=len(tr_idx),
                        nvsc=len(vsc_idx),
                        nhvdc=len(hvdc_idx),
                        nload=len(load_idx),
                        ngen=len(gen_idx),
                        nbatt=len(batt_idx),
                        nshunt=len(shunt_idx),
                        nstagen=len(stagen_idx),
                        ntime=len(time_idx),
                        sbase=self.Sbase,
                        time_array=self.time_array[time_idx],
                        apply_temperature=self.apply_temperature,
                        impedance_tolerance=self.impedance_tolerance,
                        branch_tolerance_mode=self.branch_tolerance_mode)

        nc.original_time_idx = time_idx
        nc.original_bus_idx = bus_idx
        nc.original_branch_idx = br_idx
        nc.original_tr_idx = tr_idx
        nc.original_gen_idx = gen_idx
        nc.original_bat_idx = batt_idx

        # bus ----------------------------------------------------------------------------------------------------------
        nc.bus_names = self.bus_names[bus_idx]
        nc.bus_active = self.bus_active[np.ix_(time_idx, bus_idx)]
        nc.Vbus = self.Vbus[np.ix_(time_idx, bus_idx)]
        nc.bus_types = self.bus_types[bus_idx]

        # branch common ------------------------------------------------------------------------------------------------
        nc.branch_names = self.branch_names[br_idx]
        nc.branch_active = self.branch_active[np.ix_(time_idx, br_idx)]
        nc.branch_rates = self.branch_rates[np.ix_(time_idx, br_idx)]
        nc.F = self.F[br_idx]
        nc.T = self.T[br_idx]
        nc.C_branch_bus_f = self.C_branch_bus_f[np.ix_(br_idx, bus_idx)]
        nc.C_branch_bus_t = self.C_branch_bus_t[np.ix_(br_idx, bus_idx)]

        # lines --------------------------------------------------------------------------------------------------------
        nc.line_names = self.line_names[line_idx]
        nc.line_R = self.line_R[line_idx]
        nc.line_X = self.line_X[line_idx]
        nc.line_B = self.line_B[line_idx]
        nc.line_temp_base = self.line_temp_base[line_idx]
        nc.line_temp_oper = self.line_temp_oper[line_idx]
        nc.line_alpha = self.line_alpha[line_idx]
        nc.line_impedance_tolerance = self.line_impedance_tolerance[line_idx]

        nc.C_line_bus = self.C_line_bus[np.ix_(line_idx, bus_idx)]

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        nc.tr_names = self.tr_names[tr_idx]
        nc.tr_R = self.tr_R[tr_idx]
        nc.tr_X = self.tr_X[tr_idx]
        nc.tr_G = self.tr_G[tr_idx]
        nc.tr_B = self.tr_B[tr_idx]

        nc.tr_tap_f = self.tr_tap_f[tr_idx]
        nc.tr_tap_t = self.tr_tap_t[tr_idx]
        nc.tr_tap_mod = self.tr_tap_mod[tr_idx]
        nc.tr_tap_ang = self.tr_tap_ang[tr_idx]
        nc.tr_is_bus_to_regulated = self.tr_is_bus_to_regulated[tr_idx]
        nc.tr_tap_position = self.tr_tap_position[tr_idx]
        nc.tr_min_tap = self.tr_min_tap[tr_idx]
        nc.tr_max_tap = self.tr_max_tap[tr_idx]
        nc.tr_tap_inc_reg_up = self.tr_tap_inc_reg_up[tr_idx]
        nc.tr_tap_inc_reg_down = self.tr_tap_inc_reg_down[tr_idx]
        nc.tr_vset = self.tr_vset[tr_idx]

        nc.C_tr_bus = self.C_tr_bus[np.ix_(tr_idx, bus_idx)]

        # hvdc line ----------------------------------------------------------------------------------------------------
        nc.hvdc_names = self.hvdc_names[hvdc_idx]

        nc.hvdc_active = self.hvdc_active[np.ix_(time_idx, hvdc_idx)]
        nc.hvdc_rate = self.hvdc_rate[np.ix_(time_idx, hvdc_idx)]
        nc.hvdc_Pset = self.hvdc_Pset[np.ix_(time_idx, hvdc_idx)]
        nc.hvdc_Vset_f = self.hvdc_Vset_f[np.ix_(time_idx, hvdc_idx)]
        nc.hvdc_Vset_t = self.hvdc_Vset_t[np.ix_(time_idx, hvdc_idx)]

        nc.hvdc_loss_factor = self.hvdc_loss_factor[hvdc_idx]
        nc.hvdc_Qmin_f = self.hvdc_Qmin_f[hvdc_idx]
        nc.hvdc_Qmax_f = self.hvdc_Qmax_f[hvdc_idx]
        nc.hvdc_Qmin_t = self.hvdc_Qmin_t[hvdc_idx]
        nc.hvdc_Qmax_t = self.hvdc_Qmax_t[hvdc_idx]

        nc.C_hvdc_bus_f = self.C_hvdc_bus_f[np.ix_(hvdc_idx, bus_idx)]
        nc.C_hvdc_bus_t = self.C_hvdc_bus_t[np.ix_(hvdc_idx, bus_idx)]

        # vsc converter ------------------------------------------------------------------------------------------------
        nc.vsc_names = self.vsc_names[vsc_idx]
        nc.vsc_R1 = self.vsc_R1[vsc_idx]
        nc.vsc_X1 = self.vsc_X1[vsc_idx]
        nc.vsc_Gsw = self.vsc_Gsw[vsc_idx]
        nc.vsc_Beq = self.vsc_Beq[vsc_idx]
        nc.vsc_m = self.vsc_m[vsc_idx]
        nc.vsc_theta = self.vsc_theta[vsc_idx]

        nc.C_vsc_bus = self.C_vsc_bus[np.ix_(vsc_idx, bus_idx)]

        # load ---------------------------------------------------------------------------------------------------------
        nc.load_names = self.load_names[load_idx]
        nc.load_active = self.load_active[np.ix_(time_idx, load_idx)]
        nc.load_s = self.load_s[np.ix_(time_idx, load_idx)]

        nc.C_bus_load = self.C_bus_load[np.ix_(bus_idx, load_idx)]

        # static generators --------------------------------------------------------------------------------------------
        nc.static_generator_names = self.static_generator_names[stagen_idx]
        nc.static_generator_active = self.static_generator_active[np.ix_(time_idx, stagen_idx)]
        nc.static_generator_s = self.static_generator_s[np.ix_(time_idx, stagen_idx)]

        nc.C_bus_static_generator = self.C_bus_static_generator[np.ix_(bus_idx, stagen_idx)]

        # battery ------------------------------------------------------------------------------------------------------
        nc.battery_names = self.battery_names[batt_idx]
        nc.battery_controllable = self.battery_controllable[batt_idx]

        nc.battery_active = self.battery_active[np.ix_(time_idx, batt_idx)]
        nc.battery_p = self.battery_p[np.ix_(time_idx, batt_idx)]
        nc.battery_pf = self.battery_pf[np.ix_(time_idx, batt_idx)]
        nc.battery_v = self.battery_v[np.ix_(time_idx, batt_idx)]

        nc.battery_qmin = self.battery_qmin[batt_idx]
        nc.battery_qmax = self.battery_qmax[batt_idx]

        nc.C_bus_batt = self.C_bus_batt[np.ix_(bus_idx, batt_idx)]

        # generator ----------------------------------------------------------------------------------------------------
        nc.generator_names = self.generator_names[gen_idx]
        nc.generator_controllable = self.generator_controllable[gen_idx]

        nc.generator_active = self.generator_active[np.ix_(time_idx, gen_idx)]
        nc.generator_p = self.generator_p[np.ix_(time_idx, gen_idx)]
        nc.generator_pf = self.generator_pf[np.ix_(time_idx, gen_idx)]
        nc.generator_v = self.generator_v[np.ix_(time_idx, gen_idx)]

        nc.generator_qmin = self.generator_qmin[gen_idx]
        nc.generator_qmax = self.generator_qmax[gen_idx]

        nc.C_bus_gen = self.C_bus_gen[np.ix_(bus_idx, gen_idx)]

        # shunt --------------------------------------------------------------------------------------------------------
        nc.shunt_names = self.shunt_names[shunt_idx]
        nc.shunt_active = self.shunt_active[np.ix_(time_idx, shunt_idx)]
        nc.shunt_admittance = self.shunt_admittance[np.ix_(time_idx, shunt_idx)]

        nc.C_bus_shunt = self.C_bus_shunt[np.ix_(bus_idx, shunt_idx)]

        return nc


class TimeIsland(TimeCircuit):

    def __init__(self, nbus, nline, ntr, nvsc, nhvdc, nload, ngen, nbatt, nshunt, nstagen, ntime, sbase, time_array,
                 apply_temperature=False, branch_tolerance_mode: BranchImpedanceMode = BranchImpedanceMode.Specified):
        """

        :param nbus:
        :param nline:
        :param ntr:
        :param nvsc:
        :param nhvdc:
        :param nload:
        :param ngen:
        :param nbatt:
        :param nshunt:
        :param sbase:
        :param apply_temperature:
        :param branch_tolerance_mode:
        """
        TimeCircuit.__init__(self, nbus=nbus, nline=nline, ntr=ntr, nvsc=nvsc, nhvdc=nhvdc,
                             nload=nload, ngen=ngen, nbatt=nbatt, nshunt=nshunt, nstagen=nstagen, ntime=ntime,
                             sbase=sbase, time_array=time_array,  apply_temperature=apply_temperature,
                             branch_tolerance_mode=branch_tolerance_mode)

        self.Sbus = np.zeros((self.nbus, ntime), dtype=complex)
        self.Ibus = np.zeros((self.nbus, ntime), dtype=complex)
        self.Yshunt_from_devices = np.zeros((self.nbus, ntime), dtype=complex)

        self.Qmax_bus = np.zeros((self.nbus, ntime))
        self.Qmin_bus = np.zeros((self.nbus, ntime))

        # only one Y matrix per time island, that is the guarantee we get by splitting the TimeCircuit in TimeIslands
        self.Ybus = None
        self.Yf = None
        self.Yt = None
        self.Yseries = None
        self.Yshunt = None
        # self.Ysh_helm = None
        self.B1 = None
        self.B2 = None
        self.Bpqpv = None
        self.Bref = None

        self.original_time_idx = list()
        self.original_bus_idx = list()
        self.original_branch_idx = list()
        self.original_tr_idx = list()
        self.original_gen_idx = list()
        self.original_bat_idx = list()

        self.pq = list()
        self.pv = list()
        self.vd = list()
        self.pqpv = list()

        self.available_structures = ['Vbus', 'Sbus', 'Ibus', 'Ybus', 'Yshunt', 'Yseries',
                                     "B'", "B''", 'Types', 'Jacobian', 'Qmin', 'Qmax']

    def R_corrected(self):
        """
        Returns temperature corrected resistances (numpy array) based on a formula
        provided by: NFPA 70-2005, National Electrical Code, Table 8, footnote #2; and
        https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity#Linear_approximation
        (version of 2019-01-03 at 15:20 EST).
        """
        return self.line_R * (1.0 + self.line_alpha * (self.line_temp_oper - self.line_temp_base))

    def re_calc_admittance_matrices(self, tap_module):
        """

        :param tap_module:
        :return:
        """
        self.compute_admittance_matrices(newton_raphson=False,
                                         linear_dc=False,
                                         linear_ac=False,
                                         fast_decoupled=False,
                                         helm=False,
                                         tap_module=tap_module)

    def compute_admittance_matrices(self, newton_raphson=False, linear_dc=False, linear_ac=False, fast_decoupled=False,
                                    helm=False, tap_module=None):
        """
        Compute the admittance matrices
        :return: Ybus, Yseries, Yshunt
        """

        t = self.original_time_idx[0]

        # form the connectivity matrices with the states applied -------------------------------------------------------
        br_states_diag = sp.diags(self.branch_active[t, :])
        Cf = br_states_diag * self.C_branch_bus_f
        Ct = br_states_diag * self.C_branch_bus_t

        # Declare the empty primitives ---------------------------------------------------------------------------------

        # The composition order is and will be: Pi model, HVDC, VSC
        if newton_raphson:
            Ytt = np.empty(self.nbr, dtype=complex)
            Yff = np.empty(self.nbr, dtype=complex)
            Yft = np.empty(self.nbr, dtype=complex)
            Ytf = np.empty(self.nbr, dtype=complex)
        else:
            Ytt = np.empty(0, dtype=complex)
            Yff = np.empty(0, dtype=complex)
            Yft = np.empty(0, dtype=complex)
            Ytf = np.empty(0, dtype=complex)

        # Branch primitives in vector form, for Yseries
        if linear_ac or helm:
            Ytts = np.empty(self.nbr, dtype=complex)
            Yffs = np.empty(self.nbr, dtype=complex)
            Yfts = np.empty(self.nbr, dtype=complex)
            Ytfs = np.empty(self.nbr, dtype=complex)
            ysh_br = np.empty(self.nbr, dtype=complex)
        else:
            Ytts = np.empty(0, dtype=complex)
            Yffs = np.empty(0, dtype=complex)
            Yfts = np.empty(0, dtype=complex)
            Ytfs = np.empty(0, dtype=complex)
            ysh_br = np.empty(0, dtype=complex)

        # Arrays to compose the fast decoupled
        if fast_decoupled:
            reactances = np.empty(self.nbr)
            susceptances = np.empty(self.nbr)
            all_taps = np.ones(self.nbr, dtype=complex)

        else:
            reactances = np.empty(0)
            susceptances = np.empty(0)
            all_taps = np.ones(0, dtype=complex)

        # line ---------------------------------------------------------------------------------------------------------
        a = 0
        b = self.nline

        # use the specified of the temperature-corrected resistance
        if self.apply_temperature:
            line_R = self.R_corrected()
        else:
            line_R = self.line_R

        # modify the branches impedance with the lower, upper tolerance values
        if self.branch_tolerance_mode == BranchImpedanceMode.Lower:
            line_R *= (1 - self.line_impedance_tolerance / 100.0)
        elif self.branch_tolerance_mode == BranchImpedanceMode.Upper:
            line_R *= (1 + self.line_impedance_tolerance / 100.0)

        Ys_line = 1.0 / (line_R + 1.0j * self.line_X)
        Ysh_line = 1.0j * self.line_B
        Ys_line2 = Ys_line + Ysh_line / 2.0

        # branch primitives in vector form for Ybus
        if newton_raphson:
            Ytt[a:b] = Ys_line2
            Yff[a:b] = Ys_line2
            Yft[a:b] = - Ys_line
            Ytf[a:b] = - Ys_line

        # branch primitives in vector form, for Yseries
        if linear_ac or helm:
            Ytts[a:b] = Ys_line
            Yffs[a:b] = Ys_line
            Yfts[a:b] = - Ys_line
            Ytfs[a:b] = - Ys_line
            ysh_br[a:b] = Ysh_line / 2.0

        if fast_decoupled:
            reactances[a:b] = self.line_X
            susceptances[a:b] = self.line_B

        # transformer models -------------------------------------------------------------------------------------------

        a = self.nline
        b = a + self.ntr

        Ys_tr = 1.0 / (self.tr_R + 1.0j * self.tr_X)
        Ysh_tr = 1.0j * self.tr_B
        Ys_tr2 = Ys_tr + Ysh_tr / 2.0

        if tap_module is None:
            tap = self.tr_tap_mod * np.exp(1.0j * self.tr_tap_ang)
        else:
            tap = tap_module * np.exp(1.0j * self.tr_tap_ang)

        # branch primitives in vector form for Ybus
        if newton_raphson:
            Ytt[a:b] = Ys_tr2 / (self.tr_tap_t * self.tr_tap_t)
            Yff[a:b] = Ys_tr2 / (self.tr_tap_f * self.tr_tap_f * tap * np.conj(tap))
            Yft[a:b] = - Ys_tr / (self.tr_tap_f * self.tr_tap_t * np.conj(tap))
            Ytf[a:b] = - Ys_tr / (self.tr_tap_t * self.tr_tap_f * tap)

        # branch primitives in vector form, for Yseries
        if linear_ac or helm:
            Ytts[a:b] = Ys_tr
            Yffs[a:b] = Ys_tr / (tap * np.conj(tap))
            Yfts[a:b] = - Ys_tr / np.conj(tap)
            Ytfs[a:b] = - Ys_tr / tap
            ysh_br[a:b] = Ysh_tr / 2.0

        if fast_decoupled:
            reactances[a:b] = self.tr_X
            susceptances[a:b] = self.tr_B
            all_taps[a:b] = tap

        # VSC MODEL ----------------------------------------------------------------------------------------------------
        a = self.nline + self.ntr
        b = a + self.nvsc

        Y_vsc = 1.0 / (self.vsc_R1 + 1.0j * self.vsc_X1)  # Y1

        if newton_raphson:
            Yff[a:b] = Y_vsc
            Yft[a:b] = -self.vsc_m * np.exp(1.0j * self.vsc_theta) * Y_vsc
            Ytf[a:b] = -self.vsc_m * np.exp(-1.0j * self.vsc_theta) * Y_vsc
            Ytt[a:b] = self.vsc_Gsw + self.vsc_m * self.vsc_m * (Y_vsc + 1.0j * self.vsc_Beq)

        if linear_ac or helm:
            Yffs[a:b] = Y_vsc
            Yfts[a:b] = -self.vsc_m * np.exp(1.0j * self.vsc_theta) * Y_vsc
            Ytfs[a:b] = -self.vsc_m * np.exp(-1.0j * self.vsc_theta) * Y_vsc
            Ytts[a:b] = self.vsc_m * self.vsc_m * (Y_vsc + 1.0j)

        if fast_decoupled:
            reactances[a:b] = self.vsc_X1
            susceptances[a:b] = self.vsc_Beq
            all_taps[a:b] = self.vsc_m * np.exp(1.0j * self.vsc_theta)

        # HVDC LINE MODEL ----------------------------------------------------------------------------------------------
        # does not apply since the HVDC-line model is the simplistic 2-generator model

        # SHUNT --------------------------------------------------------------------------------------------------------
        self.Yshunt_from_devices = self.C_bus_shunt * (self.shunt_admittance * self.shunt_active / self.Sbase).T

        # form the admittance matrices ---------------------------------------------------------------------------------
        if newton_raphson:
            self.Yf = sp.diags(Yff) * Cf + sp.diags(Yft) * Ct
            self.Yt = sp.diags(Ytf) * Cf + sp.diags(Ytt) * Ct
            self.Ybus = sp.csc_matrix(Cf.T * self.Yf + Ct.T * self.Yt) + sp.diags(self.Yshunt_from_devices[:, 0])

            self.Bpqpv = self.Ybus.imag[np.ix_(self.pqpv, self.pqpv)]
            self.Bref = self.Ybus.imag[np.ix_(self.pqpv, self.vd)]

        # form the admittance matrices of the series and shunt elements ------------------------------------------------
        if linear_ac or helm:
            Yfs = sp.diags(Yffs) * Cf + sp.diags(Yfts) * Ct
            Yts = sp.diags(Ytfs) * Cf + sp.diags(Ytts) * Ct
            self.Yseries = sp.csc_matrix(Cf.T * Yfs + Ct.T * Yts)
            self.Yshunt = Cf.T * ysh_br + Ct.T * ysh_br + self.Yshunt_from_devices[:, 0]

        # Form the matrices for fast decoupled -------------------------------------------------------------------------
        if fast_decoupled:
            b1 = 1.0 / (reactances + 1e-20)
            b1_tt = sp.diags(b1)
            B1f = b1_tt * Cf - b1_tt * Ct
            B1t = -b1_tt * Cf + b1_tt * Ct
            self.B1 = sparse_type(Cf.T * B1f + Ct.T * B1t)

            b2 = b1 + susceptances
            b2_ff = -(b2 / (all_taps * np.conj(all_taps))).real
            b2_ft = -(b1 / np.conj(all_taps)).real
            b2_tf = -(b1 / all_taps).real
            b2_tt = - b2

            B2f = -sp.diags(b2_ff) * Cf + sp.diags(b2_ft) * Ct
            B2t = sp.diags(b2_tf) * Cf + -sp.diags(b2_tt) * Ct
            self.B2 = sparse_type(Cf.T * B2f + Ct.T * B2t)

    def get_generator_injections(self):
        """
        Compute the active and reactive power of non-controlled generators (assuming all)
        :return:
        """
        pf2 = np.power(self.generator_pf, 2.0)
        pf_sign = (self.generator_pf + 1e-20) / np.abs(self.generator_pf + 1e-20)
        Q = pf_sign * self.generator_p * np.sqrt((1.0 - pf2) / (pf2 + 1e-20))
        return self.generator_p + 1.0j * Q

    def get_battery_injections(self):
        """
        Compute the active and reactive power of non-controlled batteries (assuming all)
        :return:
        """
        pf2 = np.power(self.battery_pf, 2.0)
        pf_sign = (self.battery_pf + 1e-20) / np.abs(self.battery_pf + 1e-20)
        Q = pf_sign * self.battery_p * np.sqrt((1.0 - pf2) / (pf2 + 1e-20))
        return self.battery_p + 1.0j * Q

    def compute_injections(self):
        """
        Compute the power
        :return: nothing, the results are stored in the class
        """

        # load
        self.Sbus = - self.C_bus_load * (self.load_s * self.load_active).T  # MW

        # static generators
        self.Sbus += self.C_bus_static_generator * (self.static_generator_s * self.static_generator_active).T  # MW

        # generators
        self.Sbus += self.C_bus_gen * (self.get_generator_injections() * self.generator_active).T

        # battery
        self.Sbus += self.C_bus_batt * (self.get_battery_injections() * self.battery_active).T

        # HVDC forced power
        if self.nhvdc:
            self.Sbus += ((self.hvdc_active * self.hvdc_Pset) * self.C_hvdc_bus_f).T
            self.Sbus -= ((self.hvdc_active * self.hvdc_Pset) * self.C_hvdc_bus_t).T

        self.Sbus /= self.Sbase

    def compute_reactive_power_limits(self):
        """
        Compute the reactive power limits per bus
        """
        # generators
        self.Qmax_bus = self.C_bus_gen * (self.generator_qmax * self.generator_active).T
        self.Qmin_bus = self.C_bus_gen * (self.generator_qmin * self.generator_active).T

        if self.nbatt > 0:
            # batteries
            self.Qmax_bus += self.C_bus_batt * (self.battery_qmax * self.battery_active).T
            self.Qmin_bus += self.C_bus_batt * (self.battery_qmin * self.battery_active).T

        if self.nhvdc > 0:
            # hvdc from
            self.Qmax_bus += ((self.hvdc_Qmax_f * self.hvdc_active) * self.C_hvdc_bus_f).T
            self.Qmin_bus += ((self.hvdc_Qmin_f * self.hvdc_active) * self.C_hvdc_bus_f).T

            # hvdc to
            self.Qmax_bus += ((self.hvdc_Qmax_t * self.hvdc_active) * self.C_hvdc_bus_t).T
            self.Qmin_bus += ((self.hvdc_Qmin_t * self.hvdc_active) * self.C_hvdc_bus_t).T

    def consolidate(self):
        """
        Computes the parameters given the filled-in information
        """
        self.compute_injections()

        self.vd, self.pq, self.pv, self.pqpv = compile_types(Sbus=self.Sbus, types=self.bus_types)

        self.compute_admittance_matrices(newton_raphson=True,
                                         linear_dc=True,
                                         linear_ac=True,
                                         fast_decoupled=True,
                                         helm=True)

        self.compute_reactive_power_limits()

    def get_structure(self, structure_type) -> pd.DataFrame:
        """
        Get a DataFrame with the input.

        Arguments:

            **structure_type** (str): 'Vbus', 'Sbus', 'Ibus', 'Ybus', 'Yshunt', 'Yseries' or 'Types'

        Returns:

            pandas DataFrame

        """

        if structure_type == 'Vbus':

            df = pd.DataFrame(data=self.Vbus, columns=['Voltage (p.u.)'], index=self.bus_names)

        elif structure_type == 'Sbus':
            df = pd.DataFrame(data=self.Sbus, columns=['Power (p.u.)'], index=self.bus_names)

        elif structure_type == 'Ibus':
            df = pd.DataFrame(data=self.Ibus, columns=['Current (p.u.)'], index=self.bus_names)

        elif structure_type == 'Ybus':
            df = pd.DataFrame(data=self.Ybus.toarray(), columns=self.bus_names, index=self.bus_names)

        elif structure_type == 'Yshunt':
            df = pd.DataFrame(data=self.Yshunt, columns=['Shunt admittance (p.u.)'], index=self.bus_names)

        elif structure_type == 'Yseries':
            df = pd.DataFrame(data=self.Yseries.toarray(), columns=self.bus_names, index=self.bus_names)

        elif structure_type == "B'":
            df = pd.DataFrame(data=self.B1.toarray(), columns=self.bus_names, index=self.bus_names)

        elif structure_type == "B''":
            df = pd.DataFrame(data=self.B2.toarray(), columns=self.bus_names, index=self.bus_names)

        elif structure_type == 'Types':
            df = pd.DataFrame(data=self.bus_types, columns=['Bus types'], index=self.bus_names)

        elif structure_type == 'Qmin':
            df = pd.DataFrame(data=self.Qmin_bus, columns=['Qmin'], index=self.bus_names)

        elif structure_type == 'Qmax':
            df = pd.DataFrame(data=self.Qmax_bus, columns=['Qmax'], index=self.bus_names)

        elif structure_type == 'Jacobian':

            J = Jacobian(self.Ybus, self.Vbus, self.Ibus, self.pq, self.pqpv)

            """
            J11 = dS_dVa[array([pvpq]).T, pvpq].real
            J12 = dS_dVm[array([pvpq]).T, pq].real
            J21 = dS_dVa[array([pq]).T, pvpq].imag
            J22 = dS_dVm[array([pq]).T, pq].imag
            """
            npq = len(self.pq)
            npv = len(self.pv)
            npqpv = npq + npv
            cols = ['dS/dVa'] * npqpv + ['dS/dVm'] * npq
            rows = cols
            df = pd.DataFrame(data=J.toarray(), columns=cols, index=rows)

        else:

            raise Exception('PF input: structure type not found')

        return df


def split_time_circuit_into_islands(numeric_circuit: TimeCircuit, ignore_single_node_islands=False) -> List[TimeIsland]:
    """
    Split circuit into islands
    :param numeric_circuit: NumericCircuit instance
    :param ignore_single_node_islands: ignore islands composed of only one bus
    :return: List[NumericCircuit]
    """

    circuit_islands = list()  # type: List[TimeIsland]

    all_buses = np.arange(numeric_circuit.nbus)
    all_time = np.arange(numeric_circuit.ntime)

    # find the probable time slices
    states = find_different_states(branch_active_prof=numeric_circuit.branch_active)

    if len(states) == 1:
        # compute the adjacency matrix
        A = tp.get_adjacency_matrix(C_branch_bus_f=numeric_circuit.C_branch_bus_f,
                                    C_branch_bus_t=numeric_circuit.C_branch_bus_t,
                                    branch_active=numeric_circuit.branch_active[0, :],
                                    bus_active=numeric_circuit.bus_active[0, :])

        # find the matching islands
        idx_islands = tp.find_islands(A)

        if len(idx_islands) == 1:  # only one state and only one island -> just copy the data --------------------------

            island = numeric_circuit.to_island()  # convert the circuit to an island
            island.consolidate()  # compute the internal magnitudes
            return [island]

        else:  # one state, many islands -> split by bus index, keep the time ------------------------------------------

            for bus_idx in idx_islands:

                if ignore_single_node_islands:

                    if len(bus_idx) > 1:
                        island = numeric_circuit.get_island(bus_idx, all_time)
                        island.consolidate()  # compute the internal magnitudes
                        circuit_islands.append(island)

                else:
                    island = numeric_circuit.get_island(bus_idx, all_time)
                    island.consolidate()  # compute the internal magnitudes
                    circuit_islands.append(island)

    else:  # -----------------------------------------------------------------------------------------------------------

        for t, t_array in states.items():

            # compute the adjacency matrix
            A = tp.get_adjacency_matrix(C_branch_bus_f=numeric_circuit.C_branch_bus_f,
                                        C_branch_bus_t=numeric_circuit.C_branch_bus_t,
                                        branch_active=numeric_circuit.branch_active[t_array, :],
                                        bus_active=numeric_circuit.bus_active[t_array, :])

            # find the matching islands
            idx_islands = tp.find_islands(A)

            if len(idx_islands) == 1:  # many time states, one island -> slice only by time ----------------------------

                island = numeric_circuit.get_island(all_buses, t_array)  # convert the circuit to an island
                island.consolidate()  # compute the internal magnitudes

                circuit_islands.append(island)

            else:  # any time states, many islands -> slice by both time and bus index ---------------------------------

                for bus_idx in idx_islands:

                    if ignore_single_node_islands:

                        if len(bus_idx) > 1:
                            island = numeric_circuit.get_island(bus_idx, t_array)
                            island.consolidate()  # compute the internal magnitudes
                            circuit_islands.append(island)

                    else:
                        island = numeric_circuit.get_island(bus_idx, t_array)
                        island.consolidate()  # compute the internal magnitudes
                        circuit_islands.append(island)

        return circuit_islands


def compile_time_circuit(circuit: MultiCircuit, apply_temperature=False,
                         branch_tolerance_mode=BranchImpedanceMode.Specified,
                         opf_results: OptimalPowerFlowTimeSeriesResults = None) -> TimeCircuit:
    """
    Compile the information of a circuit and generate the pertinent power flow islands
    :param circuit: Circuit instance
    :param apply_temperature:
    :param branch_tolerance_mode:
    :param opf_results: OptimalPowerFlowTimeSeriesResults instance
    :return: list of NumericIslands
    """

    logger = Logger()

    bus_dictionary = dict()

    # Element count
    nbus = len(circuit.buses)
    nload = 0
    ngen = 0
    n_batt = 0
    nshunt = 0
    nstagen = 0
    for bus in circuit.buses:
        nload += len(bus.loads)
        ngen += len(bus.controlled_generators)
        n_batt += len(bus.batteries)
        nshunt += len(bus.shunts)
        nstagen += len(bus.static_generators)

    nline = len(circuit.lines)
    ntr2w = len(circuit.transformers2w)
    nvsc = len(circuit.vsc_converters)
    nhvdc = len(circuit.hvdc_lines)
    ntime = len(circuit.time_profile)

    # declare the numerical circuit
    nc = TimeCircuit(nbus=nbus,
                     nline=nline,
                     ntr=ntr2w,
                     nvsc=nvsc,
                     nhvdc=nhvdc,
                     nload=nload,
                     ngen=ngen,
                     nbatt=n_batt,
                     nshunt=nshunt,
                     nstagen=nstagen,
                     ntime=ntime,
                     sbase=circuit.Sbase,
                     time_array=circuit.time_profile,
                     apply_temperature=apply_temperature,
                     branch_tolerance_mode=branch_tolerance_mode)

    # buses and it's connected elements (loads, generators, etc...)
    i_ld = 0
    i_gen = 0
    i_batt = 0
    i_sh = 0
    i_stagen = 0
    for i, bus in enumerate(circuit.buses):

        # bus parameters
        nc.bus_names[i] = bus.name
        nc.bus_active[:, i] = bus.active_prof
        nc.bus_types[i] = bus.determine_bus_type().value

        nc.Vmin[i] = bus.Vmin
        nc.Vmax[i] = bus.Vmax

        # Add buses dictionary entry
        bus_dictionary[bus] = i

        for elm in bus.loads:
            nc.load_names[i_ld] = elm.name
            nc.load_active[:, i_ld] = elm.active_prof

            if opf_results is None:
                nc.load_s[:, i_ld] = elm.P_prof + 1j * elm.Q_prof
            else:
                nc.load_s[:, i_ld] = elm.P_prof + 1j * elm.Q_prof - opf_results.load_shedding[:, i_ld]

            nc.C_bus_load[i, i_ld] = 1
            i_ld += 1

        for elm in bus.static_generators:
            nc.static_generator_names[i_stagen] = elm.name
            nc.static_generator_active[:, i_stagen] = elm.active_prof
            nc.static_generator_s[:, i_stagen] = elm.P_prof + 1j * elm.Q_prof

            nc.C_bus_static_generator[i, i_stagen] = 1
            i_stagen += 1

        for elm in bus.controlled_generators:

            nc.generator_names[i_gen] = elm.name

            nc.generator_active[:, i_gen] = elm.active_prof
            nc.generator_pf[:, i_gen] = elm.Pf_prof
            nc.generator_v[:, i_gen] = elm.Vset_prof
            nc.generator_qmin[i_gen] = elm.Qmin
            nc.generator_qmax[i_gen] = elm.Qmax
            nc.generator_controllable[i_gen] = elm.is_controlled
            nc.generator_installed_p[i_gen] = elm.Snom

            if opf_results is None:
                nc.generator_p[:, i_gen] = elm.P_prof
            else:
                nc.generator_p[:, i_gen] = opf_results.generator_power[:, i_gen] - opf_results.generator_shedding[:, i_gen]

            nc.C_bus_gen[i, i_gen] = 1

            if nc.Vbus[0, i].real == 1.0:
                nc.Vbus[:, i] = elm.Vset_prof + 1j * 0
            elif elm.Vset != nc.Vbus[0, i]:
                logger.append('Different set points at ' + bus.name + ': ' + str(elm.Vset) + ' !=' + str(nc.Vbus[0, i]))
            i_gen += 1

        for elm in bus.batteries:
            nc.battery_names[i_batt] = elm.name

            nc.battery_active[:, i_batt] = elm.active_prof

            nc.battery_pf[:, i_batt] = elm.Pf_prof
            nc.battery_v[:, i_batt] = elm.Vset_prof
            nc.battery_qmin[i_batt] = elm.Qmin
            nc.battery_qmax[i_batt] = elm.Qmax
            nc.battery_controllable[i_batt] = elm.is_controlled
            nc.battery_installed_p[i_batt] = elm.Snom

            if opf_results is None:
                nc.battery_p[:, i_batt] = elm.P_prof
            else:
                nc.battery_p[:, i_batt] = opf_results.battery_power[:, i_batt]

            nc.C_bus_batt[i, i_batt] = 1
            nc.Vbus[:, i] *= elm.Vset_prof
            i_batt += 1

        for elm in bus.shunts:
            nc.shunt_names[i_sh] = elm.name
            nc.shunt_active[:, i_sh] = elm.active_prof
            nc.shunt_admittance[:, i_sh] = elm.G_prof + 1j * elm.B

            nc.C_bus_shunt[i, i_sh] = 1
            i_sh += 1

    # Compile the lines
    for i, elm in enumerate(circuit.lines):
        # generic stuff
        nc.branch_names[i] = elm.name
        nc.branch_active[:, i] = elm.active_prof
        nc.branch_rates[:, i] = elm.rate_prof
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]
        nc.C_branch_bus_f[i, f] = 1
        nc.C_branch_bus_t[i, t] = 1
        nc.F[i] = f
        nc.T[i] = t

        # impedance
        nc.line_names[i] = elm.name
        nc.line_R[i] = elm.R
        nc.line_X[i] = elm.X
        nc.line_B[i] = elm.B
        nc.line_impedance_tolerance[i] = elm.tolerance
        nc.C_line_bus[i, f] = 1
        nc.C_line_bus[i, t] = 1

        # Thermal correction
        nc.line_temp_base[i] = elm.temp_base
        nc.line_temp_oper[i] = elm.temp_oper
        nc.line_alpha[i] = elm.alpha

    # 2-winding transformers
    for i, elm in enumerate(circuit.transformers2w):
        ii = i + nline

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        nc.branch_names[ii] = elm.name
        nc.branch_active[:, ii] = elm.active_prof
        nc.branch_rates[:, ii] = elm.rate_prof
        nc.C_branch_bus_f[ii, f] = 1
        nc.C_branch_bus_t[ii, t] = 1
        nc.F[ii] = f
        nc.T[ii] = t

        # impedance
        nc.tr_names[i] = elm.name
        nc.tr_R[i] = elm.R
        nc.tr_X[i] = elm.X
        nc.tr_G[i] = elm.G
        nc.tr_B[i] = elm.B

        nc.C_tr_bus[i, f] = 1
        nc.C_tr_bus[i, t] = 1

        # tap changer
        nc.tr_tap_mod[i] = elm.tap_module
        nc.tr_tap_ang[i] = elm.angle
        nc.tr_is_bus_to_regulated[i] = elm.bus_to_regulated
        nc.tr_tap_position[i] = elm.tap_changer.tap
        nc.tr_min_tap[i] = elm.tap_changer.min_tap
        nc.tr_max_tap[i] = elm.tap_changer.max_tap
        nc.tr_tap_inc_reg_up[i] = elm.tap_changer.inc_reg_up
        nc.tr_tap_inc_reg_down[i] = elm.tap_changer.inc_reg_down
        nc.tr_vset[i] = elm.vset

        nc.tr_bus_to_regulated_idx[i] = t if elm.bus_to_regulated else f

        # virtual taps for transformers where the connection voltage is off
        nc.tr_tap_f[i], nc.tr_tap_t[i] = elm.get_virtual_taps()

    # VSC
    for i, elm in enumerate(circuit.vsc_converters):
        ii = i + nline + ntr2w

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        nc.branch_names[ii] = elm.name
        nc.C_branch_bus_f[ii, f] = 1
        nc.C_branch_bus_t[ii, t] = 1
        nc.F[ii] = f
        nc.T[ii] = t

        nc.branch_active[:, ii] = elm.active_prof
        nc.branch_rates[:, ii] = elm.rate_prof

        # vsc values
        nc.vsc_names[i] = elm.name
        nc.vsc_R1[i] = elm.R1
        nc.vsc_X1[i] = elm.X1
        nc.vsc_Gsw[i] = elm.Gsw
        nc.vsc_Beq[i] = elm.Beq
        nc.vsc_m[i] = elm.m
        nc.vsc_theta[i] = elm.theta

        nc.C_vsc_bus[i, f] = 1
        nc.C_vsc_bus[i, t] = 1

    # HVDC
    for i, elm in enumerate(circuit.hvdc_lines):
        ii = i + nline + ntr2w + nvsc

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        # hvdc values
        nc.hvdc_names[i] = elm.name

        nc.hvdc_active[:, i] = elm.active_prof
        nc.hvdc_rate[:, i] = elm.rate_prof
        nc.hvdc_Pset[:, i] = elm.Pset_prof
        nc.hvdc_Vset_f[:, i] = elm.Vset_f_prof
        nc.hvdc_Vset_t[:, i] = elm.Vset_t_prof

        nc.hvdc_loss_factor[i] = elm.loss_factor
        nc.hvdc_Qmin_f[i] = elm.Qmin_f
        nc.hvdc_Qmax_f[i] = elm.Qmax_f
        nc.hvdc_Qmin_t[i] = elm.Qmin_t
        nc.hvdc_Qmax_t[i] = elm.Qmax_t

        # hack the bus types to believe they are PV
        nc.bus_types[f] = BusMode.PV.value
        nc.bus_types[t] = BusMode.PV.value

        # the the bus-hvdc line connectivity
        nc.C_hvdc_bus_f[i, f] = 1
        nc.C_hvdc_bus_t[i, t] = 1

    # consolidate the information
    nc.consolidate()

    return nc

