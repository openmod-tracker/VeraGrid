from typing import List
import numpy as np
import scipy.sparse as sp
from GridCal.Engine.basic_structures import BusMode, BranchImpedanceMode, Logger
from GridCal.Engine.Core.multi_circuit import MultiCircuit
import GridCal.Engine.Core.topology as tp


def compile_types(Sbus, types, logger=Logger()):
    """
    Compile the types.
    :param Sbus: array of power injections per node
    :param types: array of tentative node types
    :param logger: logger where to store the errors
    :return: ref, pq, pv, pqpv
    """

    pq = np.where(types == BusMode.PQ.value)[0]
    pv = np.where(types == BusMode.PV.value)[0]
    ref = np.where(types == BusMode.REF.value)[0]

    if len(ref) == 0:  # there is no slack!

        if len(pv) == 0:  # there are no pv neither -> blackout grid

            logger.add('There are no slack nodes selected')

        else:  # select the first PV generator as the slack

            mx = max(Sbus[pv])
            if mx > 0:
                # find the generator that is injecting the most
                i = np.where(Sbus == mx)[0][0]

            else:
                # all the generators are injecting zero, pick the first pv
                i = pv[0]

            # delete the selected pv bus from the pv list and put it in the slack list
            pv = np.delete(pv, np.where(pv == i)[0])
            ref = [i]
            # print('Setting bus', i, 'as slack')

        ref = np.ndarray.flatten(np.array(ref))
        types[ref] = BusMode.REF.value
    else:
        pass  # no problem :)

    pqpv = np.r_[pq, pv]
    pqpv.sort()

    return ref, pq, pv, pqpv


class NumericCircuit:

    def __init__(self, nbus, nline, ntr, nvsc, nhvdc, nload, ngen, nbatt, nshunt, sbase):
        """

        :param nbus: number of buses
        :param nline: number of lines
        :param ntr: number of transformers
        :param nvsc:
        :param nhvdc:
        :param nload:
        :param ngen:
        :param nbatt:
        :param nshunt:
        """

        self.nbus = nbus
        self.nline = nline
        self.ntr = ntr
        self.nvsc = nvsc
        self.nhvdc = nhvdc
        self.nload = nload
        self.ngen = ngen
        self.nbatt = nbatt
        self.nshunt = nshunt

        self.sbase = sbase

        # bus ----------------------------------------------------------------------------------------------------------
        self.bus_names = np.empty(nbus, dtype=object)
        self.bus_active = np.ones(nbus, dtype=int)
        self.V0 = np.ones(nbus, dtype=complex)
        self.bus_types = np.empty(nbus, dtype=int)
        self.bus_installed_power = np.zeros(nbus, dtype=float)

        # branch common ------------------------------------------------------------------------------------------------
        self.nbr = nline + ntr + nhvdc + nvsc  # compute the number of branches

        self.branch_names = np.empty(self.nbr, dtype=object)
        self.branch_active = np.zeros(self.nbr, dtype=int)
        self.F = np.zeros(self.nbr, dtype=int)  # indices of the "from" buses
        self.T = np.zeros(self.nbr, dtype=int)  # indices of the "to" buses
        self.br_rates = np.zeros(self.nbr, dtype=float)
        self.C_branch_bus_f = sp.lil_matrix((self.nbr, nbus), dtype=int)  # connectivity branch with their "from" bus
        self.C_branch_bus_t = sp.lil_matrix((self.nbr, nbus), dtype=int)  # connectivity branch with their "to" bus

        # lines --------------------------------------------------------------------------------------------------------
        self.line_R = np.zeros(nline, dtype=float)
        self.line_X = np.zeros(nline, dtype=float)
        self.line_B = np.zeros(nline, dtype=float)
        self.line_temp_base = np.zeros(nline, dtype=float)
        self.line_temp_oper = np.zeros(nline, dtype=float)
        self.line_alpha = np.zeros(nline, dtype=float)
        self.line_impedance_tolerance = np.zeros(nline, dtype=float)

        self.C_line_bus = sp.lil_matrix((nline, nbus), dtype=int)  # this ons is just for splitting islands

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        self.tr_R = np.zeros(ntr, dtype=float)
        self.tr_X = np.zeros(ntr, dtype=float)
        self.tr_G = np.zeros(ntr, dtype=float)
        self.tr_B = np.zeros(ntr)

        self.tr_tap_f = np.ones(ntr)  # tap generated by the difference in nominal voltage at the form side
        self.tr_tap_t = np.ones(ntr)  # tap generated by the difference in nominal voltage at the to side
        self.tr_tap_mod = np.ones(ntr)  # normal tap module
        self.tr_tap_ang = np.zeros(ntr)  # normal tap angle
        self.tr_is_bus_to_regulated = np.zeros(ntr, dtype=bool)
        self.tr_tap_position = np.zeros(ntr, dtype=int)
        self.tr_min_tap = np.zeros(ntr, dtype=int)
        self.tr_max_tap = np.zeros(ntr, dtype=int)
        self.tr_tap_inc_reg_up = np.zeros(ntr)
        self.tr_tap_inc_reg_down = np.zeros(ntr)
        self.tr_vset = np.ones(ntr)

        self.C_tr_bus = sp.lil_matrix((ntr, nbus), dtype=int)  # this ons is just for splitting islands

        # hvdc line ----------------------------------------------------------------------------------------------------
        self.hvdc_R = np.zeros(nhvdc)
        self.hvdc_Pset = np.zeros(nhvdc)

        self.C_hvdc_bus = sp.lil_matrix((nhvdc, nbus), dtype=int)  # this ons is just for splitting islands

        # vsc converter ------------------------------------------------------------------------------------------------
        self.vsc_R1 = np.zeros(nvsc)
        self.vsc_X1 = np.zeros(nvsc)
        self.vsc_Gsw = np.zeros(nvsc)
        self.vsc_Beq = np.zeros(nvsc)
        self.vsc_m = np.zeros(nvsc)
        self.vsc_theta = np.zeros(nvsc)

        self.C_vsc_bus = sp.lil_matrix((nvsc, nbus), dtype=int)  # this ons is just for splitting islands

        # load ---------------------------------------------------------------------------------------------------------
        self.load_names = np.empty(nload, dtype=object)
        self.load_active = np.zeros(nload, dtype=bool)
        self.load_s = np.zeros(nload, dtype=complex)

        self.C_bus_load = sp.lil_matrix((nbus, nload), dtype=int)

        # battery ------------------------------------------------------------------------------------------------------
        self.battery_names = np.empty(nbatt, dtype=object)
        self.battery_active = np.zeros(nbatt, dtype=bool)
        self.battery_controllable = np.zeros(nbatt, dtype=bool)
        self.battery_installed_p = np.zeros(nbatt)
        self.battery_p = np.zeros(nbatt)
        self.battery_pf = np.zeros(nbatt)
        self.battery_v = np.zeros(nbatt)
        self.battery_qmin = np.zeros(nbatt)
        self.battery_qmax = np.zeros(nbatt)

        self.C_bus_batt = sp.lil_matrix((nbus, nbatt), dtype=int)

        # generator ----------------------------------------------------------------------------------------------------
        self.generator_names = np.empty(ngen, dtype=object)
        self.generator_active = np.zeros(ngen, dtype=bool)
        self.generator_controllable = np.zeros(ngen, dtype=bool)
        self.generator_installed_p = np.zeros(ngen)
        self.generator_p = np.zeros(ngen)
        self.generator_pf = np.zeros(ngen)
        self.generator_v = np.zeros(ngen)
        self.generator_qmin = np.zeros(ngen)
        self.generator_qmax = np.zeros(ngen)

        self.C_bus_gen = sp.lil_matrix((nbus, ngen), dtype=int)

        # shunt --------------------------------------------------------------------------------------------------------
        self.shunt_names = np.empty(nshunt, dtype=object)
        self.shunt_active = np.zeros(nshunt, dtype=bool)
        self.shunt_admittance = np.zeros(nshunt, dtype=complex)

        self.C_bus_shunt = sp.lil_matrix((nbus, nshunt), dtype=int)

    def consolidate(self):
        """
        Consolidates the information of this object
        :return:
        """
        self.C_line_bus = self.C_line_bus.tocsc()
        self.C_tr_bus = self.C_tr_bus.tocsc()
        self.C_hvdc_bus = self.C_hvdc_bus.tocsc()
        self.C_vsc_bus = self.C_vsc_bus.tocsc()

        self.C_bus_load = self.C_bus_load.tocsr()
        self.C_bus_batt = self.C_bus_batt.tocsr()
        self.C_bus_gen = self.C_bus_gen.tocsr()
        self.C_bus_shunt = self.C_bus_shunt.tocsr()

        self.bus_installed_power = self.C_bus_gen * self.generator_installed_p
        self.bus_installed_power += self.C_bus_batt * self.battery_installed_p
    
    def to_island(self) -> "NumericIsland":
        """
        copy theis circuit as an island device
        :return: NumericIsland instance
        """
        island = NumericIsland(nbus=self.nbus,
                               nline=self.nline,
                               ntr=self.ntr,
                               nvsc=self.nvsc,
                               nhvdc=self.nhvdc,
                               nload=self.nload,
                               ngen=self.ngen,
                               nbatt=self.nbatt,
                               nshunt=self.nshunt,
                               sbase=self.sbase)

        island.original_bus_idx = np.arange(self.nbus)
        island.original_branch_idx = np.arange(self.nbr)

        # bus ----------------------------------------------------------------------------------------------------------
        island.bus_names = self.bus_names
        island.bus_active = self.bus_active
        island.V0 = self.V0
        island.bus_types = self.bus_types

        # branches common ----------------------------------------------------------------------------------------------
        island.branch_names = self.branch_names
        island.branch_active = self.branch_active
        island.F = self.F
        island.T = self.T
        island.br_rates = self.br_rates
        island.C_branch_bus_f = self.C_branch_bus_f
        island.C_branch_bus_t = self.C_branch_bus_t

        # lines --------------------------------------------------------------------------------------------------------
        island.line_R = self.line_R
        island.line_X = self.line_X
        island.line_B = self.line_B
        island.line_temp_base = self.line_temp_base
        island.line_temp_oper = self.line_temp_oper
        island.line_alpha = self.line_alpha
        island.line_impedance_tolerance = self.line_impedance_tolerance

        island.C_line_bus = self.C_line_bus

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        island.tr_R = self.tr_R
        island.tr_X = self.tr_X
        island.tr_G = self.tr_G
        island.tr_B = self.tr_B

        island.tr_tap_f = self.tr_tap_f
        island.tr_tap_t = self.tr_tap_t
        island.tr_tap_mod = self.tr_tap_mod
        island.tr_tap_ang = self.tr_tap_ang
        island.tr_is_bus_to_regulated = self.tr_is_bus_to_regulated
        island.tr_tap_position = self.tr_tap_position
        island.tr_min_tap = self.tr_min_tap
        island.tr_max_tap = self.tr_max_tap
        island.tr_tap_inc_reg_up = self.tr_tap_inc_reg_up
        island.tr_tap_inc_reg_down = self.tr_tap_inc_reg_down
        island.tr_vset = self.tr_vset

        island.C_tr_bus = self.C_tr_bus

        # hvdc line ----------------------------------------------------------------------------------------------------
        island.hvdc_R = self.hvdc_R
        island.hvdc_Pset = self.hvdc_Pset

        island.C_hvdc_bus = self.C_hvdc_bus

        # vsc converter ------------------------------------------------------------------------------------------------
        island.vsc_R1 = self.vsc_R1
        island.vsc_X1 = self.vsc_X1
        island.vsc_Gsw = self.vsc_Gsw
        island.vsc_Beq = self.vsc_Beq
        island.vsc_m = self.vsc_m
        island.vsc_theta = self.vsc_theta

        island.C_vsc_bus = self.C_vsc_bus

        # load ---------------------------------------------------------------------------------------------------------
        island.load_names = self.load_names
        island.load_active = self.load_active
        island.load_s = self.load_s

        island.C_bus_load = self.C_bus_load

        # battery ------------------------------------------------------------------------------------------------------
        island.battery_names = self.battery_names
        island.battery_active = self.battery_active
        island.battery_controllable = self.battery_controllable
        island.battery_p = self.battery_p
        island.battery_pf = self.battery_pf
        island.battery_v = self.battery_v
        island.battery_qmin = self.battery_qmin
        island.battery_qmax = self.battery_qmax

        island.C_bus_batt = self.C_bus_batt

        # generator ----------------------------------------------------------------------------------------------------
        island.generator_names = self.generator_names
        island.generator_active = self.generator_active
        island.generator_controllable = self.generator_controllable
        island.generator_p = self.generator_p
        island.generator_pf = self.generator_pf
        island.generator_v = self.generator_v
        island.generator_qmin = self.generator_qmin
        island.generator_qmax = self.generator_qmax

        island.C_bus_gen = self.C_bus_gen

        # shunt --------------------------------------------------------------------------------------------------------
        island.shunt_names = self.shunt_names
        island.shunt_active = self.shunt_active
        island.shunt_admittance = self.shunt_admittance

        island.C_bus_shunt = self.C_bus_shunt 
        
        return island
    
    def get_island(self, bus_idx) -> "NumericIsland":
        """
        Get the island corresponding to the given buses
        :param bus_idx: array of bus indices
        :return: NumericIsland
        """

        # find the indices of the devices of the island
        line_idx = tp.get_elements_of_the_island(self.C_line_bus, bus_idx)
        tr_idx = tp.get_elements_of_the_island(self.C_tr_bus, bus_idx)
        vsc_idx = tp.get_elements_of_the_island(self.C_vsc_bus, bus_idx)
        hvdc_idx = tp.get_elements_of_the_island(self.C_hvdc_bus, bus_idx)
        br_idx = tp.get_elements_of_the_island(self.C_branch_bus_f + self.C_branch_bus_t, bus_idx)

        load_idx = tp.get_elements_of_the_island(self.C_bus_load, bus_idx)
        gen_idx = tp.get_elements_of_the_island(self.C_bus_gen, bus_idx)
        batt_idx = tp.get_elements_of_the_island(self.C_bus_batt, bus_idx)
        shunt_idx = tp.get_elements_of_the_island(self.C_bus_shunt, bus_idx)

        nc = NumericIsland(nbus=len(bus_idx),
                           nline=len(line_idx),
                           ntr=len(tr_idx),
                           nvsc=len(vsc_idx),
                           nhvdc=len(hvdc_idx),
                           nload=len(load_idx),
                           ngen=len(gen_idx),
                           nbatt=len(batt_idx),
                           nshunt=len(shunt_idx))

        nc.original_bus_idx = bus_idx
        nc.original_branch_idx = br_idx

        # bus ----------------------------------------------------------------------------------------------------------
        nc.bus_names = nc.bus_names[bus_idx]
        nc.bus_active = nc.bus_active[bus_idx]
        nc.V0 = nc.V0[bus_idx]
        nc.bus_types = nc.bus_types[bus_idx]

        # branch common ------------------------------------------------------------------------------------------------
        nc.branch_names = nc.branch_names[br_idx]
        nc.branch_active = nc.branch_active[br_idx]
        nc.F = nc.F[br_idx]
        nc.T = nc.T[br_idx]
        nc.br_rates = nc.br_rates[br_idx]
        nc.C_branch_bus_f = nc.C_branch_bus_f[np.ix_(br_idx, bus_idx)]
        nc.C_branch_bus_t = nc.C_branch_bus_t[np.ix_(br_idx, bus_idx)]

        # lines --------------------------------------------------------------------------------------------------------
        nc.line_R = nc.line_R[line_idx]
        nc.line_X = nc.line_X[line_idx]
        nc.line_B = nc.line_B[line_idx]
        nc.line_temp_base = nc.line_temp_base[line_idx]
        nc.line_temp_oper = nc.line_temp_oper[line_idx]
        nc.line_alpha = nc.line_alpha[line_idx]
        nc.line_impedance_tolerance = nc.line_impedance_tolerance[line_idx]

        # nc.C_line_bus = sp.lil_matrix((nline, nbus), dtype=int)  # this ons is just for splitting islands

        # transformer 2W + 3W ------------------------------------------------------------------------------------------
        nc.tr_R = nc.tr_R[tr_idx]
        nc.tr_X = nc.tr_X[tr_idx]
        nc.tr_G = nc.tr_G[tr_idx]
        nc.tr_B = nc.tr_B[tr_idx]

        nc.tr_tap_f = nc.tr_tap_f[tr_idx]
        nc.tr_tap_t = nc.tr_tap_t[tr_idx]
        nc.tr_tap_mod = nc.tr_tap_mod[tr_idx]
        nc.tr_tap_ang = nc.tr_tap_ang[tr_idx]
        nc.tr_is_bus_to_regulated = nc.tr_is_bus_to_regulated[tr_idx]
        nc.tr_tap_position = nc.tr_tap_position[tr_idx]
        nc.tr_min_tap = nc.tr_min_tap[tr_idx]
        nc.tr_max_tap = nc.tr_max_tap[tr_idx]
        nc.tr_tap_inc_reg_up = nc.tr_tap_inc_reg_up[tr_idx]
        nc.tr_tap_inc_reg_down = nc.tr_tap_inc_reg_down[tr_idx]
        nc.tr_vset = nc.tr_vset[tr_idx]

        # nc.C_tr_bus = sp.lil_matrix((ntr, nbus), dtype=int)  # this ons is just for splitting islands

        # hvdc line ----------------------------------------------------------------------------------------------------
        nc.hvdc_R = nc.hvdc_R[hvdc_idx]
        nc.hvdc_Pset = nc.hvdc_Pset[hvdc_idx]

        # nc.C_hvdc_bus = sp.lil_matrix((nhvdc, nbus), dtype=int)  # this ons is just for splitting islands

        # vsc converter ------------------------------------------------------------------------------------------------
        nc.vsc_R1 = nc.vsc_R1[vsc_idx]
        nc.vsc_X1 = nc.vsc_X1[vsc_idx]
        nc.vsc_Gsw = nc.vsc_Gsw[vsc_idx]
        nc.vsc_Beq = nc.vsc_Beq[vsc_idx]
        nc.vsc_m = nc.vsc_m[vsc_idx]
        nc.vsc_theta = nc.vsc_theta[vsc_idx]

        # nc.C_vsc_bus = sp.lil_matrix((nvsc, nbus), dtype=int)  # this ons is just for splitting islands

        # load ---------------------------------------------------------------------------------------------------------
        nc.load_names = nc.load_names[load_idx]
        nc.load_active = nc.load_active[load_idx]
        nc.load_s = nc.load_s[load_idx]

        # nc.C_bus_load = sp.lil_matrix((nbus, nload), dtype=int)

        # battery ------------------------------------------------------------------------------------------------------
        nc.battery_names = nc.battery_names[batt_idx]
        nc.battery_active = nc.battery_active[batt_idx]
        nc.battery_controllable = nc.battery_controllable[batt_idx]
        nc.battery_p = nc.battery_p[batt_idx]
        nc.battery_pf = nc.battery_pf[batt_idx]
        nc.battery_v = nc.battery_v[batt_idx]
        nc.battery_qmin = nc.battery_qmin[batt_idx]
        nc.battery_qmax = nc.battery_qmax[batt_idx]

        # nc.C_bus_batt = sp.lil_matrix((nbus, nbatt), dtype=int)

        # generator ----------------------------------------------------------------------------------------------------
        nc.generator_names = nc.generator_names[gen_idx]
        nc.generator_active = nc.generator_active[gen_idx]
        nc.generator_controllable = nc.generator_controllable[gen_idx]
        nc.generator_p = nc.generator_p[gen_idx]
        nc.generator_pf = nc.generator_pf[gen_idx]
        nc.generator_v = nc.generator_v[gen_idx]
        nc.generator_qmin = nc.generator_qmin[gen_idx]
        nc.generator_qmax = nc.generator_qmax[gen_idx]

        # nc.C_bus_gen = sp.lil_matrix((nbus, ngen), dtype=int)

        # shunt --------------------------------------------------------------------------------------------------------
        nc.shunt_names = nc.shunt_names[shunt_idx]
        nc.shunt_active = nc.shunt_active[shunt_idx]
        nc.shunt_admittance = nc.shunt_admittance[shunt_idx]

        # nc.C_bus_shunt = sp.lil_matrix((nbus, nshunt), dtype=int)

        return nc


class NumericIsland(NumericCircuit):

    def __init__(self, nbus, nline, ntr, nvsc, nhvdc, nload, ngen, nbatt, nshunt, sbase):
        """

        :param nbus:
        :param nline:
        :param ntr:
        :param nvsc:
        :param nhvdc:
        :param nload:
        :param ngen:
        :param nbatt:
        :param nshunt:
        """
        NumericCircuit.__init__(self, nbus=nbus, nline=nline, ntr=ntr, nvsc=nvsc, nhvdc=nhvdc,
                                nload=nload, ngen=ngen, nbatt=nbatt, nshunt=nshunt, sbase=sbase)

        self.Sbus = np.zeros(self.nbus, dtype=complex)
        self.Ibus = np.zeros(self.nbus, dtype=complex)

        self.Qmax_bus = np.zeros(self.nbus)
        self.Qmin_bus = np.zeros(self.nbus)

        self.Ybus = None
        self.Yf = None
        self.Yt = None
        self.Yseries = None
        self.Yshunt = None

        self.original_bus_idx = list()
        self.original_branch_idx = list()

        self.pq = list()
        self.pv = list()
        self.vd = list()
        self.pqpv = list()

    def compute_admittance_matrices(self):
        """
        Compute the admittance matrices
        :return: Ybus, Yseries, Yshunt
        """
        # form the connectivity matrices with the states applied -------------------------------------------------------
        br_states_diag = sp.diags(self.branch_active)
        Cf = br_states_diag * self.C_branch_bus_f
        Ct = br_states_diag * self.C_branch_bus_t

        # Declare the empty primitives ---------------------------------------------------------------------------------

        # The composition order is and will be: Pi model, HVDC, VSC
        Ytt = np.empty(self.nbr, dtype=complex)
        Yff = np.empty(self.nbr, dtype=complex)
        Yft = np.empty(self.nbr, dtype=complex)
        Ytf = np.empty(self.nbr, dtype=complex)

        # Branch primitives in vector form, for Yseries
        Ytts = np.empty(self.nbr, dtype=complex)
        Yffs = np.empty(self.nbr, dtype=complex)
        Yfts = np.empty(self.nbr, dtype=complex)
        Ytfs = np.empty(self.nbr, dtype=complex)

        ysh_br = np.empty(self.nbr, dtype=complex)

        # line ---------------------------------------------------------------------------------------------------------

        # use the specified of the temperature-corrected resistance
        # if apply_temperature:
        #     R = R_corrected

        # modify the branches impedance with the lower, upper tolerance values
        # if branch_tolerance_mode == BranchImpedanceMode.Lower:
        #     R *= (1 - impedance_tolerance / 100.0)
        # elif branch_tolerance_mode == BranchImpedanceMode.Upper:
        #     R *= (1 + impedance_tolerance / 100.0)

        Ys_line = 1.0 / (self.line_R + 1.0j * self.line_X)
        Ysh_line = 1.0j * self.line_B
        Ys_line2 = Ys_line + Ysh_line / 2.0

        a = 0
        b = self.nline
        # branch primitives in vector form for Ybus
        Ytt[a:b] = Ys_line2
        Yff[a:b] = Ys_line2
        Yft[a:b] = - Ys_line
        Ytf[a:b] = - Ys_line

        # branch primitives in vector form, for Yseries
        Ytts[a:b] = Ys_line
        Yffs[a:b] = Ys_line
        Yfts[a:b] = - Ys_line
        Ytfs[a:b] = - Ys_line
        ysh_br[a:b] = Ysh_line / 2.0

        # transformer models -------------------------------------------------------------------------------------------

        a = self.nline
        b = a + self.ntr

        Ys_tr = 1.0 / (self.tr_R + 1.0j * self.tr_X)
        Ysh_tr = 1.0j * self.tr_B
        Ys_tr2 = Ys_tr + Ysh_tr / 2.0
        tap = self.tr_tap_mod * np.exp(1.0j * self.tr_tap_ang)

        # branch primitives in vector form for Ybus
        Ytt[a:b] = Ys_tr2 / (self.tr_tap_t * self.tr_tap_t)
        Yff[a:b] = Ys_tr2 / (self.tr_tap_f * self.tr_tap_f * tap * np.conj(tap))
        Yft[a:b] = - Ys_tr / (self.tr_tap_f * self.tr_tap_t * np.conj(tap))
        Ytf[a:b] = - Ys_tr / (self.tr_tap_t * self.tr_tap_f * tap)

        # branch primitives in vector form, for Yseries
        Ytts[a:b] = Ys_tr
        Yffs[a:b] = Ys_tr / (tap * np.conj(tap))
        Yfts[a:b] = - Ys_tr / np.conj(tap)
        Ytfs[a:b] = - Ys_tr / tap
        ysh_br[a:b] = Ysh_tr / 2.0

        # VSC MODEL ----------------------------------------------------------------------------------------------------
        a = self.nline + self.ntr
        b = a + self.nvsc

        Y_vsc = 1.0 / (self.vsc_R1 + 1.0j * self.vsc_X1)  # Y1
        Yff[a:b] = Y_vsc
        Yft[a:b] = -self.vsc_m * np.exp(1.0j * self.vsc_theta) * Y_vsc
        Ytf[a:b] = -self.vsc_m * np.exp(-1.0j * self.vsc_theta) * Y_vsc
        Ytt[a:b] = self.vsc_Gsw + self.vsc_m * self.vsc_m * (Y_vsc + 1.0j * self.vsc_Beq)

        Yffs[a:b] = Y_vsc
        Yfts[a:b] = -self.vsc_m * np.exp(1.0j * self.vsc_theta) * Y_vsc
        Ytfs[a:b] = -self.vsc_m * np.exp(-1.0j * self.vsc_theta) * Y_vsc
        Ytts[a:b] = self.vsc_m * self.vsc_m * (Y_vsc + 1.0j)

        # HVDC LINE MODEL ----------------------------------------------------------------------------------------------
        a = self.nline + self.ntr + self.nvsc
        b = a + self.nhvdc

        Ydc = 1 / self.hvdc_R

        Ytt[a:b] = Ydc
        Yff[a:b] = Ydc
        Yft[a:b] = - Ydc
        Ytf[a:b] = - Ydc

        Ytts[a:b] = Ydc
        Yffs[a:b] = Ydc
        Yfts[a:b] = - Ydc
        Ytfs[a:b] = - Ydc

        # SHUNT --------------------------------------------------------------------------------------------------------
        Yshunt_from_devices = self.C_bus_shunt * (self.shunt_admittance * self.shunt_active / self.sbase)
        
        # form the admittance matrices ---------------------------------------------------------------------------------
        self.Yf = sp.diags(Yff) * Cf + sp.diags(Yft) * Ct
        self.Yt = sp.diags(Ytf) * Cf + sp.diags(Ytt) * Ct
        self.Ybus = sp.csc_matrix(Cf.T * self.Yf + Ct.T * self.Yt + sp.diags(Yshunt_from_devices))

        # form the admittance matrices of the series and shunt elements ------------------------------------------------
        Yfs = sp.diags(Yffs) * Cf + sp.diags(Yfts) * Ct
        Yts = sp.diags(Ytfs) * Cf + sp.diags(Ytts) * Ct
        self.Yseries = sp.csc_matrix(Cf.T * Yfs + Ct.T * Yts)

        self.Yshunt = Yshunt_from_devices + Cf.T * ysh_br + Ct.T * ysh_br

    def get_generator_injections(self):
        """
        Compute the active and reactive power of non-controlled generators (assuming all)
        :return:
        """
        pf2 = np.power(self.generator_pf, 2.0)
        pf_sign = (self.generator_pf + 1e-20) / np.abs(self.generator_pf + 1e-20)
        Q = pf_sign * self.generator_p * np.sqrt((1.0 - pf2) / (pf2 + 1e-20))
        return self.generator_p + 1.0j * Q

    def get_battery_injections(self):
        """
        Compute the active and reactive power of non-controlled batteries (assuming all)
        :return:
        """
        pf2 = np.power(self.battery_pf, 2.0)
        pf_sign = (self.battery_pf + 1e-20) / np.abs(self.battery_pf + 1e-20)
        Q = pf_sign * self.battery_p * np.sqrt((1.0 - pf2) / (pf2 + 1e-20))
        return self.battery_p + 1.0j * Q

    def compute_injections(self):
        """
        Compute the power
        :return: nothing, the results are stored in the class
        """
        self.Sbus = - self.C_bus_load * (self.load_s * self.load_active)  # MW

        # generators
        self.Sbus += self.C_bus_gen * (self.get_generator_injections() * self.generator_active)

        # battery
        self.Sbus += self.C_bus_batt * (self.get_battery_injections() * self.battery_active)

        # HVDC forced power
        if self.nhvdc:
            self.Sbus += self.hvdc_Pset * self.C_hvdc_bus

        self.Sbus /= self.sbase

    def compute_reactive_power_limits(self):

        self.Qmax_bus = self.C_bus_gen * self.generator_qmax
        self.Qmin_bus = self.C_bus_gen * self.generator_qmin

    def consolidate(self):
        """
        Computes the parameters given the filled-in information
        :return:
        """
        self.compute_injections()

        self.vd, self.pq, self.pv, self.pqpv = compile_types(Sbus=self.Sbus, types=self.bus_types)
        
        self.compute_admittance_matrices()

        self.compute_reactive_power_limits()
        

def split_into_islands(numeric_circuit: NumericCircuit) -> List[NumericIsland]:
    """
    Split circuit into islands
    :param numeric_circuit: NumericCircuit instance
    :return: List[NumericCircuit]
    """

    # compute the adjacency matrix
    A = tp.get_adjacency_matrix(C_branch_bus_f=numeric_circuit.C_branch_bus_f,
                                C_branch_bus_t=numeric_circuit.C_branch_bus_t,
                                branch_active=numeric_circuit.branch_active,
                                bus_active=numeric_circuit.bus_active)

    # find the matching islands
    idx_islands = tp.find_islands(A)

    if len(idx_islands) == 1:
        island = numeric_circuit.to_island()  # convert the circuit to an island
        island.consolidate()  # compute the internal magnitudes
        return [island]

    else:

        circuit_islands = list()  # type: List[NumericIsland]

        for bus_idx in idx_islands:
            island = numeric_circuit.get_island(bus_idx)
            island.consolidate()  # compute the internal magnitudes
            circuit_islands.append(island)

        return circuit_islands


def compile_power_flow_circuit(circuit: MultiCircuit, apply_temperature=False,
                               branch_tolerance_mode=BranchImpedanceMode.Specified,
                               ignore_single_node_islands=True) -> NumericCircuit:
    """
    Compile the information of a circuit and generate the pertinent power flow islands
    :param circuit: MultiCircuit instance
    :param apply_temperature:
    :param branch_tolerance_mode:
    :param ignore_single_node_islands:
    :return: list of NumericIslands
    """

    logger = Logger()

    bus_dictionary = dict()

    # Element count
    nbus = len(circuit.buses)
    nload = 0
    ngen = 0
    n_batt = 0
    nshunt = 0
    for bus in circuit.buses:
        nload += len(bus.loads)
        ngen += len(bus.generators)
        n_batt += len(bus.batteries)
        nshunt += len(bus.shunts)

    nline = len(circuit.lines)
    ntr2w = len(circuit.transformers2w)
    ntr3w = len(circuit.transformers3w)
    nvsc = len(circuit.vsc)
    nhvdc = len(circuit.hvdc_lines)

    # declare the numerical circuit
    nc = NumericCircuit(nbus=nbus,
                        nline=nline,
                        ntr=ntr2w + 3 * ntr3w,
                        nvsc=nvsc,
                        nhvdc=nhvdc,
                        nload=nload,
                        ngen=ngen,
                        nbatt=n_batt,
                        nshunt=nshunt,
                        sbase=circuit.Sbase)

    # buses and it's connected elements (loads, generators, etc...)
    i_ld = 0
    i_gen = 0
    i_batt = 0
    i_sh = 0
    for i, bus in enumerate(circuit.buses):

        # bus parameters
        nc.bus_names[i] = bus.name
        nc.bus_active[i] = bus.active
        nc.bus_types[i] = bus.determine_bus_type().value

        # Add buses dictionary entry
        bus_dictionary[bus] = i

        for elm in bus.loads:
            nc.load_names[i_ld] = elm.name
            nc.load_active[i_ld] = elm.active
            nc.load_s[i_ld] = complex(elm.P, elm.Q)
            nc.C_bus_load[i, i_ld] = 1
            i_ld += 1

        for elm in bus.generators:
            nc.generator_names[i_gen] = elm.name
            nc.generator_pf[i_gen] = elm.Pf
            nc.generator_v[i_gen] = elm.Vset
            nc.generator_qmin[i_gen] = elm.Qmin
            nc.generator_qmax[i_gen] = elm.Qmax
            nc.generator_active[i_gen] = elm.active
            nc.generator_controllable[i_gen] = elm.is_controlled
            nc.generator_p[i_gen] = elm.P
            nc.generator_installed_p[i_gen] = elm.Snom

            nc.C_bus_gen[i, i_gen] = 1

            if nc.V0[i].real == 1.0:
                nc.V0[i] = complex(elm.Vset, 0)
            elif elm.Vset != nc.V0[i]:
                logger.append('Different set points at ' + bus.name + ': ' + str(elm.Vset) + ' !=' + str(nc.V0[i]))
            i_gen += 1

        for elm in bus.batteries:
            nc.battery_names[i_batt] = elm.name
            nc.battery_p[i_batt] = elm.P
            nc.battery_pf[i_batt] = elm.Pf
            nc.battery_v[i_batt] = elm.Vset
            nc.battery_qmin[i_batt] = elm.Qmin
            nc.battery_qmax[i_batt] = elm.Qmax
            nc.battery_active[i_batt] = elm.active
            nc.battery_controllable[i_batt] = elm.is_controlled
            nc.battery_installed_p[i_batt] = elm.Snom

            nc.C_bus_batt[i, i_batt] = 1
            nc.V0[i] *= elm.Vset
            i_batt += 1

        for elm in bus.shunts:
            nc.shunt_names[i_sh] = elm.name
            nc.shunt_active[i_sh] = elm.active
            nc.shunt_admittance[i_sh] = complex(elm.G, elm.B)

            nc.C_bus_shunt[i, i_sh] = 1
            i_sh += 1

    # Compile the lines
    for i, elm in enumerate(circuit.lines):
        # generic stuff
        nc.branch_names[i] = elm.name
        nc.branch_active[i] = elm.active
        nc.br_rates[i] = elm.rate
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]
        nc.C_branch_bus_f[i, f] = 1
        nc.C_branch_bus_t[i, t] = 1
        nc.F[i] = f
        nc.T[i] = t

        # impedance
        nc.line_R[i] = elm.R
        nc.line_X[i] = elm.X
        nc.line_B[i] = elm.B
        nc.line_impedance_tolerance[i] = elm.tolerance
        nc.C_line_bus[i, f] = 1
        nc.C_line_bus[i, t] = 1

        # Thermal correction
        nc.line_temp_base[i] = elm.temp_base
        nc.line_temp_oper[i] = elm.temp_oper
        nc.line_alpha[i] = elm.alpha

    # 2-winding transformers
    for i, elm in enumerate(circuit.transformers2w):
        ii = i + nline

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        nc.branch_names[ii] = elm.name
        nc.branch_active[ii] = elm.active
        nc.br_rates[ii] = elm.rate
        nc.C_branch_bus_f[ii, f] = 1
        nc.C_branch_bus_t[ii, t] = 1
        nc.F[ii] = f
        nc.T[ii] = t

        # impedance
        nc.tr_R[i] = elm.R
        nc.tr_X[i] = elm.X
        nc.tr_G[i] = elm.G
        nc.tr_B[i] = elm.B

        nc.C_tr_bus[i, f] = 1
        nc.C_tr_bus[i, t] = 1

        # tap changer
        nc.tr_tap_mod[i] = elm.tap_module
        nc.tr_tap_ang[i] = elm.angle
        nc.tr_is_bus_to_regulated[i] = elm.bus_to_regulated
        nc.tr_tap_position[i] = elm.tap_changer.tap
        nc.tr_min_tap[i] = elm.tap_changer.min_tap
        nc.tr_max_tap[i] = elm.tap_changer.max_tap
        nc.tr_tap_inc_reg_up[i] = elm.tap_changer.inc_reg_up
        nc.tr_tap_inc_reg_down[i] = elm.tap_changer.inc_reg_down
        nc.tr_vset[i] = elm.vset

        # virtual taps for transformers where the connection voltage is off
        nc.tr_tap_f[i], nc.tr_tap_t[i] = elm.get_virtual_taps()

    # 3-winding transformers
    for i, elm in enumerate(circuit.transformers3w):
        """
        The 3-winding transformer is modelled as 3 separated 2-winding transformers
        """

        # create indices
        ii = i + nline + ntr2w + nvsc + nhvdc
        ii1 = ii
        ii2 = ii + 1
        ii3 = ii + 2
        i1 = i
        i2 = i + 1
        i3 = i + 2

        # Common to the branches
        b1 = bus_dictionary[elm.bus_1]
        b2 = bus_dictionary[elm.bus_2]
        b3 = bus_dictionary[elm.bus_3]

        # winding 1-2
        nc.branch_names[ii1] = elm.name + '_12'
        nc.branch_active[ii1] = elm.active
        nc.br_rates[ii1] = elm.rate12
        nc.C_branch_bus_f[ii1, b1] = 1
        nc.C_branch_bus_t[ii1, b2] = 1
        nc.F[ii] = b1
        nc.T[ii] = b2

        # winding 2-3
        nc.branch_names[ii2] = elm.name + '_23'
        nc.branch_active[ii2] = elm.active
        nc.br_rates[ii2] = elm.rate23
        nc.C_branch_bus_f[ii2, b2] = 1
        nc.C_branch_bus_t[ii2, b3] = 1
        nc.F[ii2] = b2
        nc.T[ii2] = b3

        # winding 1-3
        nc.branch_names[ii3] = elm.name + '_13'
        nc.branch_active[ii3] = elm.active
        nc.br_rates[ii3] = elm.rate13
        nc.C_branch_bus_f[ii3, b1] = 1
        nc.C_branch_bus_t[ii3, b3] = 1
        nc.F[ii3] = b1
        nc.T[ii3] = b3

        # store the connectivity per winding
        nc.C_line_bus[ntr2w + i1, b1] = 1
        nc.C_line_bus[ntr2w + i1, b2] = 1
        nc.C_line_bus[ntr2w + i2, b2] = 1
        nc.C_line_bus[ntr2w + i2, b3] = 1
        nc.C_line_bus[ntr2w + i3, b1] = 1
        nc.C_line_bus[ntr2w + i3, b3] = 1

        # values of the 3-winding transformer
        nc.tr_R[i1] = elm.R12
        nc.tr_X[i1] = elm.X12
        nc.tr_R[i2] = elm.R23
        nc.tr_X[i2] = elm.X23
        nc.tr_R[i3] = elm.R13
        nc.tr_X[i3] = elm.X13

    # VSC
    for i, elm in enumerate(circuit.vsc):
        ii = i + nline + ntr2w + 3 * ntr3w

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        nc.branch_names[ii] = elm.name
        nc.branch_active[ii] = elm.active
        nc.br_rates[ii] = elm.rate
        nc.C_branch_bus_f[ii, f] = 1
        nc.C_branch_bus_t[ii, t] = 1
        nc.F[ii] = f
        nc.T[ii] = t

        # vsc values
        nc.vsc_R1[i] = elm.R1
        nc.vsc_X1[i] = elm.X1
        nc.vsc_Gsw[i] = elm.Gsw
        nc.vsc_Beq[i] = elm.Beq
        nc.vsc_m[i] = elm.m
        nc.vsc_theta[i] = elm.theta

        nc.C_vsc_bus[i, f] = 1
        nc.C_vsc_bus[i, t] = 1

    # HVDC
    for i, elm in enumerate(circuit.hvdc_lines):
        ii = i + nline + ntr2w + 3 * ntr3w + nvsc

        # generic stuff
        f = bus_dictionary[elm.bus_from]
        t = bus_dictionary[elm.bus_to]

        nc.branch_names[ii] = elm.name
        nc.branch_active[ii] = elm.active
        nc.br_rates[ii] = elm.rate
        nc.C_branch_bus_f[ii, f] = 1
        nc.C_branch_bus_t[ii, t] = 1
        nc.F[ii] = f
        nc.T[ii] = t

        # hvdc values
        nc.hvdc_R[i] = elm.R
        nc.hvdc_Pset[i] = elm.Pset

        nc.C_hvdc_bus[i, f] = 1
        nc.C_hvdc_bus[i, t] = -1

    # consolidate the information
    nc.consolidate()

    return nc

